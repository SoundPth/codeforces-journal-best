# Бинарный поиск
## Что такое бинарный поиск?
**Бинарный поиск** — это метод решения задач, который основан на делении пополам (Разделяй и властвуй), a также эффективный алгоритм поиска элемента в отсортированном массиве (или другом контейнере с произвольным доступом). **Его сложность — O(log n)**, что гораздо быстрее линейного поиска (O(n)).
### Дана задача ###
Пусть нам загадали число от 1 до N. Мы должны отгадать число, задавая вопросы вида: «Верно ли, что загаданное число меньше X?», где X — некоторое натуральное число. Желательно задавать как можно меньше вопросов.<br>

Используя бинарный поиск можно отгадать число за O(log n).
---
Для этого сначала зададим вопрос для X ≈ N / 2, чтобы вне зависимости от полученного ответа сократить диапазон поиска примерно в два раза. И будем поступать так на каждом шаге. Если на текущий момент мы знаем, что наше число находится в диапазоне от L до R, то будем задавать вопрос для X ≈ (R+L) / 2.

>Чтобы написать бинарный поиск для решения задачи, будем опираться на подход, который использует понятие **инварианта**. Любая задача на бинпоиск сводится к тому, что некоторое условие выполнено для всех натуральных (или целых) индексов до какого-то значения, а после этого значения условие не выполнено для всех индексов.

И задача состоит в том, чтобы найти либо последний индекс, для которого условие выполнено, либо первый индекс, для которого условие не выполнено. Сначала необходимо найти **целые индексы L и R такие**, что для индекса L условие выполнено, а для индекса R условие не выполнено — это правило для индексов L и R сохраняется на всех шагах алгоритма и называется **инвариантом**. 

Далее на каждом шаге алгоритма бинарного поиска мы будем брать число в середине отрезка [L,R], которое можно вычислить по формуле **M = (R+L) / 2**. Если условие для индекса **M выполнено**, то мы можем левую границу бинарного поиска сдвинуть в M, тем самым перейдя *от отрезка [L,R] к отрезку [M,R]*. Если же условие для индекса M не выполнено, то мы можем правую границу бинарного поиска сдвинуть в M, тем самым перейдя *от отрезка [L,R] к отрезку [L,M]*. В любом случае наш отрезок сократится примерно в два раза, что нам и требуется. 

Алгоритм бинарного поиска будет выполняться до тех пор, пока *границы поиска L и R не станут двумя соседними числами*. А так как при выполнении нашего алгоритма мы сохраняли инвариант, то на последнем шаге индекс L будет последним индексом, для которого условие выполнено, а индекс R будет первым индексом, для которого условие не выполнено.

```Рассмотрим типичную реализацию алгоритма бинарного поиска на языке C++. Пусть некоторое условие выполнено для L = 0 и не выполнено для R = 100. Тогда код бинарного поиска можно реализовать следующим образом.```

```cpp
int L = 0;
int R = 100;
while (R - L > 1) {
    int M = (R + L) / 2;
    if (ok(M))
        L = M;
    else
        R = M;
}
```
При этом где-то выше должна быть реализована функция ok, которая получает целый индекс и возвращает true, если условие задачи для этого индекса выполнено, и false в противном случае.

# Бинарный поиск в массиве

Рассмотрим задачу о поиске заданного числа в отсортированном массиве. Пусть заданы число x и отсортированный массив a0⩽a1⩽…⩽an−1. Требуется найти, на какой позиции в массиве стоит число x, либо определить, что такого числа в массиве нет. Сначала добавим в наш массив два фиктивных элемента — элемент −∞ с индексом −1 и элемент +∞ с индексом n. Получим массив: −∞<a0⩽a1⩽…⩽an−1<+∞.

Тогда мы можем выбрать следующие границы бинпоиска: L=−1, R=n, потому что на позиции −1 стоит число заведомо меньшее, чем число x, а на позиции n стоит число заведомо большее, чем число x.

Далее мы можем выбрать один из двух инвариантов для решения нашей задачи.

## Инвариант 1.
**a[L]<x
a[R]≥x**
После того как алгоритм бинарного поиска с таким инвариантом закончит свою работу и индексы L и R окажутся соседними числами, то число x надо искать на позиции с индексом R. Если R=n, то это будет означать, что числа x нет в массиве. Если R<n и a[R]≠x, то числа x нет в массиве. Если же R<n и a[R]=x, то число x найдено на позиции с индексом R. Причём, если в массиве есть несколько элементов равных числу x, то индекс R задаёт позицию первого вхождения числа x в массив. Таким образом, при данном инварианте индекс R будет задавать нижнюю границу вхождений числа x, и поэтому такой индекс R принято называть LowerBound.

##Инвариант 2.
**a[L]≤x
a[R]>x**
После того как алгоритм бинарного поиска с таким инвариантом закончит свою работу и индексы L и R окажутся соседними числами, то число x надо искать на позиции с индексом L. Если L=−1, то это будет означать, что числа x нет в массиве. Если L⩾0 и a[L]≠x, то числа x нет в массиве. Если же L⩾0 и a[L]=x, то число x найдено на позиции с индексом L. Причём, если в массиве есть несколько элементов равных числу x, то индекс L задаёт позицию последнего вхождения числа x в массив. Таким образом, при данном инварианте индекс R будет задавать позицию, которая следует после последнего вхождения числа x, то есть верхнюю границу вхождений числа x, и поэтому такой индекс R принято называть UpperBound.

Для решения задач достаточно одного из двух предложенных инвариантов. Но бывает удобно использовать эти инварианты в паре. Например, если нам необходимо найти количество чисел в нашем массиве, для которых выполнено условие l⩽ai⩽r, то их количество можно найти по формуле UpperBound(r) —LowerBound(l). Удобство этой формулы в том, что она работает верно во всех случаях.
Приведём код на языке C++, который реализует бинарный поиск числа x в отсортированном массиве a с использованием инварианта 1.
``` cpp
int L = -1;
int R = n;
while (R - L > 1) {
    int M = (R + L) / 2;
    (a[M] < x ? L : R) = M;
}
if (R < n && a[R] == x)
    cout << R << endl;
else
    cout << -1 << endl;
```
