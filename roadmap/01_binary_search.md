# Бинарный поиск
## Что такое бинарный поиск?
**Бинарный поиск** — это метод решения задач, который основан на делении пополам (Разделяй и властвуй), a также эффективный алгоритм поиска элемента в отсортированном массиве (или другом контейнере с произвольным доступом). **Его сложность — O(log n)**, что гораздо быстрее линейного поиска (O(n)).
### Дана задача ###
Пусть нам загадали число от 1 до N. Мы должны отгадать число, задавая вопросы вида: «Верно ли, что загаданное число меньше X?», где X — некоторое натуральное число. Желательно задавать как можно меньше вопросов.<br>

Используя бинарный поиск можно отгадать число за O(log n).
---
Для этого сначала зададим вопрос для X ≈ N / 2, чтобы вне зависимости от полученного ответа сократить диапазон поиска примерно в два раза. И будем поступать так на каждом шаге. Если на текущий момент мы знаем, что наше число находится в диапазоне от L до R, то будем задавать вопрос для X ≈ (R+L) / 2.

>Чтобы написать бинарный поиск для решения задачи, будем опираться на подход, который использует понятие **инварианта**. Любая задача на бинпоиск сводится к тому, что некоторое условие выполнено для всех натуральных (или целых) индексов до какого-то значения, а после этого значения условие не выполнено для всех индексов.

И задача состоит в том, чтобы найти либо последний индекс, для которого условие выполнено, либо первый индекс, для которого условие не выполнено. Сначала необходимо найти **целые индексы L и R такие**, что для индекса L условие выполнено, а для индекса R условие не выполнено — это правило для индексов L и R сохраняется на всех шагах алгоритма и называется **инвариантом**. 

Далее на каждом шаге алгоритма бинарного поиска мы будем брать число в середине отрезка [L,R], которое можно вычислить по формуле **M = (R+L) / 2**. Если условие для индекса **M выполнено**, то мы можем левую границу бинарного поиска сдвинуть в M, тем самым перейдя *от отрезка [L,R] к отрезку [M,R]*. Если же условие для индекса M не выполнено, то мы можем правую границу бинарного поиска сдвинуть в M, тем самым перейдя *от отрезка [L,R] к отрезку [L,M]*. В любом случае наш отрезок сократится примерно в два раза, что нам и требуется. 

Алгоритм бинарного поиска будет выполняться до тех пор, пока *границы поиска L и R не станут двумя соседними числами*. А так как при выполнении нашего алгоритма мы сохраняли инвариант, то на последнем шаге индекс L будет последним индексом, для которого условие выполнено, а индекс R будет первым индексом, для которого условие не выполнено.

``` Рассмотрим типичную реализацию алгоритма бинарного поиска на языке C++. Пусть некоторое условие выполнено для L = 0 и не выполнено для R = 100. Тогда код бинарного поиска можно реализовать следующим образом.```

```cpp
int L = 0;
int R = 100;
while (R - L > 1) {
    int M = (R + L) / 2;
    if (ok(M))
        L = M;
    else
        R = M;
}
```
При этом где-то выше должна быть реализована функция ok, которая получает целый индекс и возвращает true, если условие задачи для этого индекса выполнено, и false в противном случае.

# Бинарный поиск в массиве
